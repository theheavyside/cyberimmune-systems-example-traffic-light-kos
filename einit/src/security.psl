use nk.basic._

execute: kl.core.Execute

use nk.base._

use EDL Einit
use EDL kl.VfsNet
use EDL kl.core.NameServer
use EDL kl.core.Core
use EDL kl.drivers.BSP
use EDL kl.drivers.GPIO

use EDL traffic_light.KlogEntity
use EDL traffic_light.KlogStorageEntity

use EDL traffic_light.ControlSystem
use EDL traffic_light.LightsGPIO
use EDL traffic_light.Diagnostics

request src=traffic_light.KlogEntity dst=traffic_light.KlogStorageEntity interface=kl.KlogStorage method=write { grant () }
response src=traffic_light.KlogStorageEntity dst=traffic_light.KlogEntity interface=kl.KlogStorage method=write { grant () }

request src=traffic_light.KlogEntity, dst=kl.core.Core {
    // Interface to the Synchronization service.
    match interface=kl.core.Sync { grant () }
    // Interface to the Task service.
    match interface=kl.core.Task {
        match method=FreeSelfEnv { grant () }
        match method=GetPath { grant () }
        match method=GetName { grant () }
        match method=Exit { grant () }
    }
    // Interface to the Virtual Memory Manager (VMM) service.
    match interface=kl.core.VMM { grant () }
    // Interface to the Thread service.
    match interface=kl.core.Thread { grant () }
    // Interface to the Hal service.
    match interface=kl.core.HAL, method=DebugWrite { grant () }
    match interface=kl.core.HAL, method=GetEnv { grant () }
    // Interface to the HandleManager service.
    match interface=kl.core.Handle { grant () }
    // Audit interface of the Vlog component.
    match interface=kl.core.Audit { grant () }
}

response src=kl.core.Core, dst=traffic_light.KlogEntity { grant () }

request src=traffic_light.KlogStorageEntity, dst=kl.core.Core {
    // Interface to the Synchronization service.
    match interface=kl.core.Sync { grant () }
    // Interface to the Task service.
    match interface=kl.core.Task {
        match method=FreeSelfEnv { grant () }
        match method=GetPath { grant () }
        match method=GetName { grant () }
        match method=Exit { grant () }
    }
    // Interface to the Virtual Memory Manager (VMM) service.
    match interface=kl.core.VMM { grant () }
    // Interface to the Thread service.
    match interface=kl.core.Thread { grant () }
    // Interface to the Hal service.
    match interface=kl.core.HAL, method=DebugWrite { grant () }
    match interface=kl.core.HAL, method=GetEnv { grant () }
    // Interface to the HandleManager service.
    match interface=kl.core.Handle { grant () }
}

response src=kl.core.Core, dst=traffic_light.KlogStorageEntity { grant () }

error {
    grant ()
}

execute src = Einit, dst = kl.drivers.BSP
{
    grant()
}

request src = kl.drivers.BSP, dst = kl.core.Core
{
    grant()
}

response src = kl.core.Core, dst = kl.drivers.BSP
{
    grant()
}

execute src = Einit, dst = kl.drivers.GPIO
{
    grant()
}

request src = kl.drivers.GPIO, dst = kl.core.Core
{
    grant()
}

response src = kl.core.Core, dst = kl.drivers.GPIO
{
    grant()
}

execute {
    grant ()
}

request src=traffic_light.ControlSystem {
    grant ()
}

request src=traffic_light.Diagnostics dst=kl.core.Core {
    grant ()
}

request src=traffic_light.ControlSystem dst=kl.core.Core {
    grant ()
}

request src=traffic_light.ControlSystem 
    dst=traffic_light.LightsGPIO 
    endpoint=lightsGpio.mode 
    method=FMode {
        /* white list of states */
        assert(bool.any [
            message.value == 0x101,
            message.value == 0x103,
            message.value == 0x104,
            message.value == 0x102,
            message.value == 0x301,
            message.value == 0x401,
            message.value == 0x201,
            message.value == 0xA0A])        
}

request src=Einit {
    grant ()
}

request src=kl.core.Core {
    grant ()
}

execute src=Einit, dst=kl.VfsNet
{
    grant()
}

request src=kl.VfsNet, dst=kl.core.Core
{
    grant()
}

response src=kl.core.Core, dst=kl.VfsNet
{
    grant()
}

request src=traffic_light.Diagnostics, dst=kl.VfsNet
{
    grant()
}

response src=kl.VfsNet, dst=traffic_light.Diagnostics
{
    grant()
}

request src=traffic_light.LightsGPIO dst=kl.core.Core {
    grant ()
}

response {
    grant ()
}

error {
    grant ()
}

security {
    grant ()
}

policy object audit_trace : Base {}

request src=traffic_light.Diagnostics,
    dst=traffic_light.LightsGPIO,
    endpoint=diagStatus.status,
    method=GetStatus {
        audit_trace.grant()
}

response src=traffic_light.LightsGPIO,
    dst=traffic_light.Diagnostics
    endpoint=diagStatus.status,
    method=GetStatus {
        audit_trace.grant()
}

// We declare the profile for audit.
audit profile trace = {
    // Complete silence.
    0: {},
    // Only denied by kss.
    1: {
        base: {
            kss: [ "denied" ]
        },
    },
    // Only denied from everyone.
    2: {
        base: {
            kss: [ "denied" ]
        },
        audit_trace: {
            kss: [ "denied" ]
        }
    },
    // All listening.
    3: {
        base: {
            kss: [ "granted", "denied" ]
        },
        audit_trace: {
            kss: [ "granted", "denied" ]
        },
    },
    // audit_trace messages only
    4: {
        base: { kss: [] },
        audit_trace: {
            kss: [ "granted", "denied" ]
        },
    },
}

/* Разрешаем kl.core.NameServer взаимодействовать с ядром. */
request src=kl.core.NameServer, dst=kl.core.Core
{
    grant()
}
response src=kl.core.Core, dst=kl.core.NameServer
{
    grant()
}

/* Разрешаем любым задачам взаимодействовать с kl.core.NameServer */
request dst=kl.core.NameServer
{
    grant()
}
response src=kl.core.NameServer
{
    grant()
}

audit default = trace 4
